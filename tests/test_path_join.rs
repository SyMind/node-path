use camino::Utf8PathBuf;

const JOIN_TESTS: &[(&[&str], &str)] = &[
    (&[".", "x/b", "..", "/b/c.js"], "x/b/c.js"),
    (&[], "."),
    (&["/.", "x/b", "..", "/b/c.js"], "/x/b/c.js"),
    (&["/foo", "../../../bar"], "/bar"),
    (&["foo", "../../../bar"], "../../bar"),
    (&["foo/", "../../../bar"], "../../bar"),
    (&["foo/x", "../../../bar"], "../bar"),
    (&["foo/x", "./bar"], "foo/x/bar"),
    (&["foo/x/", "./bar"], "foo/x/bar"),
    (&["foo/x/", ".", "bar"], "foo/x/bar"),
    (&["./"], "./"),
    (&[".", "./"], "./"),
    (&[".", ".", "."], "."),
    (&[".", "./", "."], "."),
    (&[".", "/./", "."], "."),
    (&[".", "/////./", "."], "."),
    (&["."], "."),
    (&["", "."], "."),
    (&["", "foo"], "foo"),
    (&["foo", "/bar"], "foo/bar"),
    (&["", "/foo"], "/foo"),
    (&["", "", "/foo"], "/foo"),
    (&["", "", "foo"], "foo"),
    (&["foo", ""], "foo"),
    (&["foo/", ""], "foo/"),
    (&["foo", "", "/bar"], "foo/bar"),
    (&["./", "..", "/foo"], "../foo"),
    (&["./", "..", "..", "/foo"], "../../foo"),
    (&[".", "..", "..", "/foo"], "../../foo"),
    (&["", "..", "..", "/foo"], "../../foo"),
    (&["/"], "/"),
    (&["/", "."], "/"),
    (&["/", ".."], "/"),
    (&["/", "..", ".."], "/"),
    (&[""], "."),
    (&["", ""], "."),
    (&[" /foo"], " /foo"),
    (&[" ", "foo"], " /foo"),
    (&[" ", "."], " "),
    (&[" ", "/"], " /"),
    (&[" ", ""], " "),
    (&["/", "foo"], "/foo"),
    (&["/", "/foo"], "/foo"),
    (&["/", "//foo"], "/foo"),
    (&["/", "", "/foo"], "/foo"),
    (&["", "/", "foo"], "/foo"),
    (&["", "/", "/foo"], "/foo"),
];

#[test]
fn test_path_join() {
    JOIN_TESTS.iter().for_each(|(paths, expected)| {
        let mut path = Utf8PathBuf::new();
        for p in *paths {
            path = path.join(p);
        }
        assert_eq!(path.normalize().as_str(), *expected);
    });
}
